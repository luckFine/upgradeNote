词法作用域就是定义在词法阶段的作用域
由于作用域是函数级的,所以词法作用域由函数声明的位置决定
词法阶段:

var a = 1;
(function(){
    var a = 2;
}())
遮蔽效应,标识符的检索在匹配到第一个为止.


欺骗词法:修改词法
通过eval:
var a = 1;
(function(){
    eval('var a = 2;');
}())
动态写入a,使得a好像原来就在这个词法作用域下声明的一样,从而屏蔽window的a
在'use strict'下,eval会创建自己的词法作用域,从而避免这个问题
类似的,还有setTimeout传入字符串,new Function最后一个参数接受字符串,并生成函数体
欺骗词法带来的好处无法抵消性能的损失

with:重复引用同一个对象的快捷方式
可能造成内存泄漏
function fn(obj){
    with(obj){
        a = 2;
    }
}
fn({a:1});  //  这样正确
fn({});     //  找不到a,所以lhs会创建一个全局变量a
with会为对象创建一个新的,针对对象属性的,完全隔离的词法作用域
如果with操作的对象没有属性a,并且在这个作用域中使用var a,会创建局部变量给with所在作用域


性能:
js引擎在编译阶段会进行优化,有些优化依赖于词法分析,并预先确定所有函数和变量的位置,以便快速查询标识符
对于eval和with,只能假设标识符的位置是无效的,因为无法知道接受的参数

小结:
词法作用域意味着作用域是由函数声明时的位置决定