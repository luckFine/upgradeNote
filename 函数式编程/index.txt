一个范畴变成另一个范畴的过程，叫态射，程序实现是函数

函数式编程是用于研究函数定义，函数应用于函数递归的形式的系统
它是借助数学的方式，用js实现它，而不是单纯的用函数编程

不能用变量，只传参
不用语句，只用表达式
没有副作用
不修改状态
引用透明



纯函数：
固定的输入一定会得到固定的输出
所以slice是纯函数，splice就不是啦
优点：可以缓存
因为固定的输入有固定的输出，所以，我可以把曾经用过的值缓存下来，比如sin(12)的值是固定的，永远不变

柯里化：
一种使用部分参数创建定向函数的方式，如jq对于对象判断的方式,[object object]
bind也是非常经典的柯里化过程
柯里化是对函数参数的缓存

函数组合
解决回调地狱：a(b(c(xx)))，变成compose(a,b,c)
优点：
可以把自带函数组合在一起,如string.split().reverse().join()

声明式与命令式
声明式：for(var i ...
命令式：[].map(


纯的函数式编程没有副作用，但是不纯的函数式编程有很多副作用
很容易理解，不纯的函数，可能会耦合


高阶函数:
把函数作为参数，已达到更高程度抽象

尾递归：
我懂
最后一行调用自身只是尾调用,最后一步调用自身才是尾递归
查看调用栈：console.trace()
非尾递归下：要记录调用时的深度和位置信息，性能不好
尾递归优化：
es6的提案：尾递归下，只有一个执行帧
但是报错了就玩不了了，不知道具体哪个函数报错了
强制尾递归优化：
return continue或!return或#function
尾递归优化的实现一般是while，向while看齐，并且保留数学表达式的能力
能用while就用while，少用递归



第二部分：
范畴和容器：
函数式编程，因为他是数学计算，所以不能有副作用。只不过是恰好用这个数学思想用于编程了。相当于数学里的映射关系。
容器，包括了值和变形关系。比如jquery对象，并不是dom，而是对dom进行了封装。
函子：可以将当前容器映射成另一个容器的，特殊的容器。
对于函数式编程的运算，是不针对值的，而是针对这个值的容器--函子。
因此，函数式编程就是操作各种函子。
各类方法：
of方法：用于形成容器，不挂在原型链
maybe函子：if else
either函子：用于设置默认值，默认是左值，操作是右值，如果没有传右值，就使用默认值左值
ap函子：当传入的值是一个函数的时候，需要将这个函数求值，再挂到val上。

函数式编程真是博大精深！




函数式编程的流行框架
redux
bind polifile
rxjs
看obeserver文档
underscore
loadsh.js





编写函数式编程
1.创建函数
2.强制new
3.把方法挂在prototype上